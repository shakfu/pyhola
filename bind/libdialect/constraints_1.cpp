#include <libdialect/constraints.h>
#include <libdialect/expansion.h>
#include <libdialect/faces.h>
#include <libdialect/ortho.h>
#include <sstream> // __str__

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <cstdlib>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_libdialect_constraints_1(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // dialect::ProjSeq file:libdialect/constraints.h line:492
		pybind11::class_<dialect::ProjSeq, std::shared_ptr<dialect::ProjSeq>> cl(M("dialect"), "ProjSeq", "Projection Sequence. Manages a sequence of VPSC projections onto a monotonially\n increasing set of separation constraints.");
		cl.def( pybind11::init( [](){ return new dialect::ProjSeq(); } ) );
		cl.def("addProjection", (void (dialect::ProjSeq::*)(int, int)) &dialect::ProjSeq::addProjection, "Add a new set of SepCos, ensuring monotonicity by uniting with\n         the previous set of constraints in the same dimension, if any.\n \n\n  The new set of SepCos to be added.\n \n\n  The dimension in which the new set is to operate.\n\nC++: dialect::ProjSeq::addProjection(int, int) --> void", pybind11::arg("sepCos"), pybind11::arg("dim"));
		cl.def("nextProjection", (int (dialect::ProjSeq::*)()) &dialect::ProjSeq::nextProjection, "Get the next Projection, if any.\n \n\n  The next Projection if there is another one, else nullptr.\n\nC++: dialect::ProjSeq::nextProjection() --> int");
		cl.def("noteStresschange", (void (dialect::ProjSeq::*)(double)) &dialect::ProjSeq::noteStresschange, "Note a stress change.\n\nC++: dialect::ProjSeq::noteStresschange(double) --> void", pybind11::arg("dS"));
		cl.def("toString", (int (dialect::ProjSeq::*)() const) &dialect::ProjSeq::toString, "Write a string representation.\n\nC++: dialect::ProjSeq::toString() const --> int");
		cl.def("__iadd__", (class dialect::ProjSeq & (dialect::ProjSeq::*)(const class dialect::ProjSeq &)) &dialect::ProjSeq::operator+=, "When another ProjSeq is added to this one, we simply add each\n         Projection from the other one to this one, as usual. Thus is\n         monotonicity maintained, and this ProjSeq's pointer is left in place.\n\nC++: dialect::ProjSeq::operator+=(const class dialect::ProjSeq &) --> class dialect::ProjSeq &", pybind11::return_value_policy::automatic, pybind11::arg("rhs"));
		cl.def("getAllConstraints", (int (dialect::ProjSeq::*)() const) &dialect::ProjSeq::getAllConstraints, "Get the set of all constraints, in both dimensions.\n\nC++: dialect::ProjSeq::getAllConstraints() const --> int");
		cl.def("reset", (void (dialect::ProjSeq::*)()) &dialect::ProjSeq::reset, "Reset to start of sequence.\n\nC++: dialect::ProjSeq::reset() --> void");
		cl.def("violation", (double (dialect::ProjSeq::*)() const) &dialect::ProjSeq::violation, "Sum the violations of all SepCos in the final sets.\n\nC++: dialect::ProjSeq::violation() const --> double");
	}
	{ // dialect::ExpansionManager file:libdialect/expansion.h line:98
		pybind11::class_<dialect::ExpansionManager, std::shared_ptr<dialect::ExpansionManager>> cl(M("dialect"), "ExpansionManager", "The ExpansionManager class\n\n    An instance of this class is meant to manage the generation of nonoverlap\n    constraints, when making room for a TreePlacement in a Face of a planar\n    orthogonal layout.\n\n    The idea is that we choose strategic \"goal points\" in the face, and compute\n    the line segments from the tree's attachment point to these goal points.\n    We can then use these line segments to determine the nonoverlap constraints\n    by pushing everything on one side of the line to one side, and everything\n    on the other side of the line to the other side.\n\n    A TreePlacement has both a \"placement direction\" dp, and a \"growth\n    direction\" dg. The former is any compass point, cardinal or ordinal, while\n    the latter must be cardinal. Expansion constraints are said to be \"axial\"\n    when they operate in the dimension to which dg belongs, and to be\n    \"transverse\" when they operate in the complementary dimension.\n    For example if dg is NORTH, then SepCo's in the y-dim are axial,\n    while those in the x-dim are transverse.\n\n    Similarly, goal points are called axial or transverse according to the type\n    of constraints they generate. If the placement direction dp is cardinal, then\n    there is one transverse goal point, and there are two axial goal poitns.\n    If the placement direction dp is ordinal, there there is one transverse and\n    one axial goal point.\n\n    For example, for a north-growing tree that was also placed north, see the\n    figure on the left, below. Rooted at the \"o\", the three goal points are marked\n    by \"a\", \"b\", \"c\". Goal point \"a\" is the one transverse goal point, since it will\n    generate expansion constraints operating left and right, i.e. in the x-dimension.\n    Meanwhile points \"b\" and \"c\" are the two axial goal points, since they will\n    generate expansion constraints operating up and down, i.e. in the y-dimension.\n\n                ---a---         a-------\n               |      |         |      |\n               |      |         |      |\n               c---o--b         o------b\n\n    The figure on the right shows the two goal points for a north-growing tree that\n    was placed north-east. Here there is one transverse goal point (\"a\"), and one\n    axial (\"b\").\n\n    For each goal point the ExpansionManager constructs an ExpansionGoal object,\n    which in turn uses the ContainedSegment class to generate expansion constraints.\n\n    Note: In an earlier version of HOLA (the Python version from 2015), this process\n    was much more complex, potentially considering many more goal points, spanning\n    face concavities. In those caes libavoid was used to find an orthogonal route\n    to the goal point, and the segments of the route were used to select the expansion\n    constraints. That system allowed us to consider all possible ways of expanding\n    a face. The present system is faster and simpler, and is deemed to produce\n    results of equal quality.");
		cl.def( pybind11::init( [](){ return new dialect::ExpansionManager(); } ) );
		cl.def( pybind11::init( [](int const & a0){ return new dialect::ExpansionManager(a0); } ), "doc" , pybind11::arg("tp"));
		cl.def( pybind11::init( [](int const & a0, int const & a1){ return new dialect::ExpansionManager(a0, a1); } ), "doc" , pybind11::arg("tp"), pybind11::arg("primaryDim"));
		cl.def( pybind11::init<int, int, double>(), pybind11::arg("tp"), pybind11::arg("primaryDim"), pybind11::arg("padding") );

		cl.def("isAxial", (bool (dialect::ExpansionManager::*)(int)) &dialect::ExpansionManager::isAxial, "Check whether a given dimension is axial w.r.t. this manager's placement.\n\nC++: dialect::ExpansionManager::isAxial(int) --> bool", pybind11::arg("dim"));
		cl.def("isTransverse", (bool (dialect::ExpansionManager::*)(int)) &dialect::ExpansionManager::isTransverse, "Check whether a given dimension is transverse w.r.t. this manager's placement.\n\nC++: dialect::ExpansionManager::isTransverse(int) --> bool", pybind11::arg("dim"));
		cl.def("estimateCost", (double (dialect::ExpansionManager::*)() const) &dialect::ExpansionManager::estimateCost, "Estimate the cost of expanding.\n\nC++: dialect::ExpansionManager::estimateCost() const --> double");
		cl.def("estimateCostByDimension", (int (dialect::ExpansionManager::*)() const) &dialect::ExpansionManager::estimateCostByDimension, "Estimate the cost of expanding in each dimension.\n         This method looks at the length of contained segments, and reports the\n         sum of shortfalls.\n\nC++: dialect::ExpansionManager::estimateCostByDimension() const --> int");
		cl.def("estimateCostByDimension2", (int (dialect::ExpansionManager::*)() const) &dialect::ExpansionManager::estimateCostByDimension2, "Estimate the cost of expanding in each dimension.\n         This method computes the initial separation constraints in each dimension and\n         reports the sum of their violations.\n\nC++: dialect::ExpansionManager::estimateCostByDimension2() const --> int");
		cl.def("estimateCostByDirection", (int (dialect::ExpansionManager::*)() const) &dialect::ExpansionManager::estimateCostByDirection, "Estimate the cost of expanding in each cardinal direction.\n\nC++: dialect::ExpansionManager::estimateCostByDirection() const --> int");
		cl.def("getGoals", (int (dialect::ExpansionManager::*)()) &dialect::ExpansionManager::getGoals, "Access the goals.\n\nC++: dialect::ExpansionManager::getGoals() --> int");
		cl.def("extendProjSeq", (int (dialect::ExpansionManager::*)(int)) &dialect::ExpansionManager::extendProjSeq, "Extend a given projection sequence with those projections necessary\n         to achieve all expansion goals of this manager.\n \n\n  The given ProjSeq.\n \n\n A new ProjSeq that extends the given one, or nullptr if any attempted\n     projection is impossible.\n\nC++: dialect::ExpansionManager::extendProjSeq(int) --> int", pybind11::arg("ps0"));
	}
	{ // dialect::ExpansionGoal file:libdialect/expansion.h line:170
		pybind11::class_<dialect::ExpansionGoal, std::shared_ptr<dialect::ExpansionGoal>> cl(M("dialect"), "ExpansionGoal", "The ExpansionGoal class\n\n Manages a single expansion goal point, as utilised by the ExpansionManager class.\n\n ");
		cl.def( pybind11::init( [](){ return new dialect::ExpansionGoal(); } ) );
		cl.def( pybind11::init<unsigned int, int, int, double>(), pybind11::arg("id"), pybind11::arg("tp"), pybind11::arg("direc"), pybind11::arg("padding") );

		cl.def("computeContainedSegment", [](dialect::ExpansionGoal &o) -> int { return o.computeContainedSegment(); }, "");
		cl.def("computeContainedSegment", (int (dialect::ExpansionGoal::*)(bool)) &dialect::ExpansionGoal::computeContainedSegment, "Compute the contained segment for this goal.\n\n \n  This is useful when we are interested in\n computing estimates of expansion costs. At such times, we want to guess how long\n the contained segment might be once any collateral tree boxes have been moved away\n (but without actually doing the moving).\n\nC++: dialect::ExpansionGoal::computeContainedSegment(bool) --> int", pybind11::arg("ignoreCollateralTreeBoxes"));
		cl.def("getDirec", (int (dialect::ExpansionGoal::*)() const) &dialect::ExpansionGoal::getDirec, "Get the direction of the goal.\n\nC++: dialect::ExpansionGoal::getDirec() const --> int");
		cl.def("tryExpansionRec", (int (dialect::ExpansionGoal::*)(int, int &)) &dialect::ExpansionGoal::tryExpansionRec, "Try to expand, and work recursively, attempting all remaining goals.\n \n\n  The projection sequence to be extended.\n \n\n  Deque of ExpansionGoals on which to recurse.\n \n\n  The resulting projection sequence, in which all expansion goals\n          have been achieved, or nullptr if any attempted projection is impossible.\n\nC++: dialect::ExpansionGoal::tryExpansionRec(int, int &) --> int", pybind11::arg("ps0"), pybind11::arg("remainingGoals"));
	}
	{ // dialect::ContainedSegment file:libdialect/expansion.h line:220
		pybind11::class_<dialect::ContainedSegment, std::shared_ptr<dialect::ContainedSegment>> cl(M("dialect"), "ContainedSegment", "");
		cl.def( pybind11::init( [](){ return new dialect::ContainedSegment(); } ) );
		cl.def( pybind11::init<unsigned int, int, int, int, double, int, int>(), pybind11::arg("goalID"), pybind11::arg("basept"), pybind11::arg("localGoalPt"), pybind11::arg("globalGoalPt"), pybind11::arg("padding"), pybind11::arg("tp"), pybind11::arg("sepDim") );

		cl.def_readwrite("goalID", &dialect::ContainedSegment::goalID);
		cl.def_readwrite("basept", &dialect::ContainedSegment::basept);
		cl.def_readwrite("localGoalPt", &dialect::ContainedSegment::localGoalPt);
		cl.def_readwrite("globalGoalPt", &dialect::ContainedSegment::globalGoalPt);
		cl.def_readwrite("padding", &dialect::ContainedSegment::padding);
		cl.def_readwrite("tp", &dialect::ContainedSegment::tp);
		cl.def_readwrite("sepDim", &dialect::ContainedSegment::sepDim);
		cl.def_readwrite("localGoalSeg", &dialect::ContainedSegment::localGoalSeg);
		cl.def_readwrite("globalGoalSeg", &dialect::ContainedSegment::globalGoalSeg);
		cl.def("measureShortage", (double (dialect::ContainedSegment::*)() const) &dialect::ContainedSegment::measureShortage, "Report the \"shortage\", i.e. the extent to which the global goal\n         segment exceeds the local in length. Returns zero if this value\n         would be negative.\n\nC++: dialect::ContainedSegment::measureShortage() const --> double");
		cl.def("toString", (int (dialect::ContainedSegment::*)() const) &dialect::ContainedSegment::toString, "Write a string representation.\n\nC++: dialect::ContainedSegment::toString() const --> int");
		cl.def("makeRoomForTreeNode", [](dialect::ContainedSegment &o, int const & a0) -> bool { return o.makeRoomForTreeNode(a0); }, "", pybind11::arg("ps0"));
		cl.def("makeRoomForTreeNode", (bool (dialect::ContainedSegment::*)(int, bool)) &dialect::ContainedSegment::makeRoomForTreeNode, "Perform expansion, to make room for the tree node, extending a given\n         projection sequence with the projections performed.\n \n\n  The ProjSeq to be extended.\n \n\n  Set false in order to do a 'trial' in which you only extend the given\n                       ProjSeq, but do not actually project.\n \n\n  false if any attempted projection is impossible; else true\n\nC++: dialect::ContainedSegment::makeRoomForTreeNode(int, bool) --> bool", pybind11::arg("ps0"), pybind11::arg("doProject"));
	}
	{ // dialect::Side file:libdialect/faces.h line:43
		pybind11::class_<dialect::Side, std::shared_ptr<dialect::Side>> cl(M("dialect"), "Side", "A side of a Face. E.g. a rectangular Face has four Sides: north, south, east, and west.");
		cl.def( pybind11::init( [](){ return new dialect::Side(); } ) );
		cl.def( pybind11::init<int, int>(), pybind11::arg("nodeSeq"), pybind11::arg("direc") );

		cl.def("getNodeSeq", (int (dialect::Side::*)() const) &dialect::Side::getNodeSeq, "Get a copy of the node sequence.\n\nC++: dialect::Side::getNodeSeq() const --> int");
		cl.def("containsNode", (bool (dialect::Side::*)(unsigned int) const) &dialect::Side::containsNode, "Check whether this Side contains a Node of the given ID.\n\nC++: dialect::Side::containsNode(unsigned int) const --> bool", pybind11::arg("id"));
		cl.def("findNodeIndex", (unsigned long (dialect::Side::*)(unsigned int) const) &dialect::Side::findNodeIndex, "Get the index of a Node in this Side's node sequence.\n \n\n  The ID of the Node to be found.\n \n\n  The index where the given ID occurs, or -1 if not found.\n\nC++: dialect::Side::findNodeIndex(unsigned int) const --> unsigned long", pybind11::arg("id"));
		cl.def("getForwardDirec", (int (dialect::Side::*)() const) &dialect::Side::getForwardDirec, "Check the forward direction of this Side.\n\nC++: dialect::Side::getForwardDirec() const --> int");
		cl.def("getAlignmentDimension", (int (dialect::Side::*)() const) &dialect::Side::getAlignmentDimension, "Check the dimension in which this Side is aligned.\n\nC++: dialect::Side::getAlignmentDimension() const --> int");
		cl.def("firstNode", (int (dialect::Side::*)() const) &dialect::Side::firstNode, "Get a pointer to the first Node on this Side.\n\nC++: dialect::Side::firstNode() const --> int");
		cl.def("lastNode", (int (dialect::Side::*)() const) &dialect::Side::lastNode, "Get a pointer to the last Node on this Side.\n\nC++: dialect::Side::lastNode() const --> int");
		cl.def("toString", (int (dialect::Side::*)() const) &dialect::Side::toString, "Write a string representation.\n\nC++: dialect::Side::toString() const --> int");
		cl.def("getCentreCoord", (double (dialect::Side::*)() const) &dialect::Side::getCentreCoord, "Check the centre coordinate of this Side.\n \n\n  We are working under the assumption that all Nodes belonging to a given\n        Side are centre-aligned!\n\nC++: dialect::Side::getCentreCoord() const --> double");
		cl.def("getNumRootNodes", (unsigned long (dialect::Side::*)() const) &dialect::Side::getNumRootNodes, "Check how many of the Nodes on this Side are marked as root nodes.\n\nC++: dialect::Side::getNumRootNodes() const --> unsigned long");
		cl.def("addTreePlacement", (void (dialect::Side::*)(int)) &dialect::Side::addTreePlacement, "Record a TreePlacement as having been placed on this Side.\n\nC++: dialect::Side::addTreePlacement(int) --> void", pybind11::arg("tp"));
		cl.def("computeCollateralProjSeq", [](dialect::Side &o, int const & a0) -> int { return o.computeCollateralProjSeq(a0); }, "", pybind11::arg("tp"));
		cl.def("computeCollateralProjSeq", (int (dialect::Side::*)(int, double)) &dialect::Side::computeCollateralProjSeq, "Compute a projection sequence to remove/prevent overlaps between the given\n         TreePlacement's tree box, and any existing tree boxes already on this Side,\n         as well as ordinary perimeter nodes on this Side.\n \n\n  The TreePlacement to be added to this Side.\n \n\n  Optional padding for the new tree box.\n \n\n  A ProjSeq representing the computed projection sequence.\n\nC++: dialect::Side::computeCollateralProjSeq(int, double) --> int", pybind11::arg("tp"), pybind11::arg("padding"));
		cl.def("closedInterval", (int (dialect::Side::*)() const) &dialect::Side::closedInterval, "Compute the closed interval [a, b], where a and b are the extreme coordinates\n         covered by this Side, up to the extremes of the boxes of the extreme Nodes.\n \n\n The closed interval covered by the Side.\n\nC++: dialect::Side::closedInterval() const --> int");
		cl.def("getIntervalOppositeSegment", [](dialect::Side const &o, struct dialect::LineSegment & a0) -> int { return o.getIntervalOppositeSegment(a0); }, "", pybind11::arg("seg"));
		cl.def("getIntervalOppositeSegment", (int (dialect::Side::*)(struct dialect::LineSegment &, bool) const) &dialect::Side::getIntervalOppositeSegment, "Compute the closed interval [a, b] that is the intersection of this Side's\n         closed interval with that of a given Segment.\n \n\n  The LineSegment in question.\n \n\n  Set true if you want to instead intersect this Side's closed\n                          interval with the LineSegment's open interval.\n \n\n  An interval representing the intersection.\n \n\n  Returns an empty interval (b < a) if the two intervals do not intersect, or\n        if the Side and the LineSegment are not aligned in the same dimension.\n\nC++: dialect::Side::getIntervalOppositeSegment(struct dialect::LineSegment &, bool) const --> int", pybind11::arg("seg"), pybind11::arg("openInterval"));
		cl.def("liesOppositeSegment", [](dialect::Side const &o, struct dialect::LineSegment & a0) -> bool { return o.liesOppositeSegment(a0); }, "", pybind11::arg("seg"));
		cl.def("liesOppositeSegment", (bool (dialect::Side::*)(struct dialect::LineSegment &, bool) const) &dialect::Side::liesOppositeSegment, "Check whether the closed interval spanned by this Side runs in the same\n         dimension as a given line segment, and overlaps it in projection onto\n         that dimension.\n \n\n  The LineSegment in question.\n \n\n  Set true if you want to instead intersect this Side's closed\n                          interval with the LineSegment's open interval.\n \n\n boolean\n\nC++: dialect::Side::liesOppositeSegment(struct dialect::LineSegment &, bool) const --> bool", pybind11::arg("seg"), pybind11::arg("openInterval"));
		cl.def("getFirstPtOppositeSegment", (int (dialect::Side::*)(struct dialect::LineSegment &) const) &dialect::Side::getFirstPtOppositeSegment, "Compute the first point of the interval of this Side that lies opposite\n         a given line segment.\n \n\n  The LineSegment in question.\n \n\n  The Point.\n \n\n  Runtime error if this Side does not lie opposite the given segment.\n \n\n Side::liesOppositeSegment\n\nC++: dialect::Side::getFirstPtOppositeSegment(struct dialect::LineSegment &) const --> int", pybind11::arg("seg"));
		cl.def("halfWidthOppositeSegment", (double (dialect::Side::*)(struct dialect::LineSegment &) const) &dialect::Side::halfWidthOppositeSegment, "Given a LineSegment, find that portion of this Side that lies opposite it,\n         (if any) and report the maximum half-width of the near half.\n \n\n  The LineSegment in question.\n \n\n  The desired half-width. Will be equal to -1 if the Side's interval does not intersect\n          that of the segment, or if it does but the two are in-line with one another.\n \n\n  The Edges of the Side are given the thickness value set for aligned edges in the underlying Graph.\n\nC++: dialect::Side::halfWidthOppositeSegment(struct dialect::LineSegment &) const --> double", pybind11::arg("seg"));
		cl.def("getTreePlacements", (const int & (dialect::Side::*)() const) &dialect::Side::getTreePlacements, "Read-only access to the set of TreePlacements that have been attached to this Side.\n\nC++: dialect::Side::getTreePlacements() const --> const int &", pybind11::return_value_policy::automatic);
	}
}
