#include <libdialect/constraints.h>
#include <libdialect/faces.h>
#include <libdialect/ortho.h>
#include <sstream> // __str__

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <cstdlib>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_libdialect_faces(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	// dialect::NexusPolarity file:libdialect/faces.h line:164
	pybind11::enum_<dialect::NexusPolarity>(M("dialect"), "NexusPolarity", "")
		.value("ENTER_FROM", dialect::NexusPolarity::ENTER_FROM)
		.value("EXIT_TO", dialect::NexusPolarity::EXIT_TO);

;

	{ // dialect::Nexus file:libdialect/faces.h line:182
		pybind11::class_<dialect::Nexus, std::shared_ptr<dialect::Nexus>> cl(M("dialect"), "Nexus", "Regarded as a member of a Face F, a Node u belongs to certain Sides si\n of F. As we traverse the face in the clockwise direction (i.e. so that the\n interior of the face is always to the /right/), each Side si gets a direction,\n and therefore may stand in one of eight relations to Node u: it may be /entering/\n or /exiting/, and this may be from or to any of the four cardinal compass directions.\n\n A single Side may stand in two such relations, as when the Node lies along\n the middle of the Side, or else in just one such relation, as when a Node\n lies at one end or the other.\n\n A Nexus represents a Node in this capacity as a \"joining point\" of several\n Sides of a Face. It stores eight \"slots\" that are either empty or else occupied by\n a Side object.");
		cl.def( pybind11::init<int>(), pybind11::arg("u") );

		cl.def("addSide", (void (dialect::Nexus::*)(int)) &dialect::Nexus::addSide, "Add a Side to the Nexus.\n\nC++: dialect::Nexus::addSide(int) --> void", pybind11::arg("side"));
		cl.def("getNeighboursOfADirection", (int (dialect::Nexus::*)(int)) &dialect::Nexus::getNeighboursOfADirection, "Find out what are the first objects you hit as you try sweeping both\n         clockwise and anticlockwise, starting from a given direction.\n \n\n  The given direction.\n \n\n  Set of Sides.\n \n\n  The size of the returned set will be either 0, 1, or 2, according to whether\n        the number of filled slots in this Nexus is 0, 1, or more, respectively.\n\nC++: dialect::Nexus::getNeighboursOfADirection(int) --> int", pybind11::arg("direc"));
		cl.def("toString", (int (dialect::Nexus::*)() const) &dialect::Nexus::toString, "Write a string representation.\n\nC++: dialect::Nexus::toString() const --> int");
	}
	{ // dialect::FaceSet file:libdialect/faces.h line:251
		pybind11::class_<dialect::FaceSet, std::shared_ptr<dialect::FaceSet>> cl(M("dialect"), "FaceSet", "Holds all the Face objects for a given 4-planar, orthogonal layout,\n and provides methods to use and manage them.");
		cl.def( pybind11::init<int &>(), pybind11::arg("G") );

		cl.def("getNumFaces", (unsigned long (dialect::FaceSet::*)()) &dialect::FaceSet::getNumFaces, "Check how many faces there are.\n\nC++: dialect::FaceSet::getNumFaces() --> unsigned long");
		cl.def("listAllPossibleTreePlacements", (int (dialect::FaceSet::*)(int)) &dialect::FaceSet::listAllPossibleTreePlacements, "Compute all the possible ways of placing a given Tree into the Faces,\n         given that it must connect at a particular root node in the underlying Graph.\n \n\n  The Tree to be placed.\n \n\n Face::listAllPossibleTreePlacements.\n\nC++: dialect::FaceSet::listAllPossibleTreePlacements(int) --> int", pybind11::arg("tree"));
		cl.def("getAllTreePlacements", (int (dialect::FaceSet::*)()) &dialect::FaceSet::getAllTreePlacements, "After tree placements have actually been chosen and performed (i.e. trees have\n         been placed into faces), obtain a vector of all those TreePlacements that were\n         actually chosen.\n\nC++: dialect::FaceSet::getAllTreePlacements() --> int");
		cl.def("getFaces", (int (dialect::FaceSet::*)()) &dialect::FaceSet::getFaces, "Get a copy of the vector of Faces_SP's.\n\nC++: dialect::FaceSet::getFaces() --> int");
		cl.def("getExternalFace", (int (dialect::FaceSet::*)()) &dialect::FaceSet::getExternalFace, "Get the external Face.\n\nC++: dialect::FaceSet::getExternalFace() --> int");
		cl.def("getNumTreesByGrowthDir", [](dialect::FaceSet const &o) -> int { return o.getNumTreesByGrowthDir(); }, "");
		cl.def("getNumTreesByGrowthDir", (int (dialect::FaceSet::*)(bool) const) &dialect::FaceSet::getNumTreesByGrowthDir, "After tree placements have been chosen and performed, get a count of trees\n         by growth direction.\n \n\n  Set true if for each tree you actually want to count its number\n                         of nodes. In other words, the final counts you get actually indicate\n                         the number of nodes in trees that grow in the given directions.\n\nC++: dialect::FaceSet::getNumTreesByGrowthDir(bool) const --> int", pybind11::arg("scaleBySize"));
	}
	{ // dialect::Face file:libdialect/faces.h line:304
		pybind11::class_<dialect::Face, std::shared_ptr<dialect::Face>> cl(M("dialect"), "Face", "Represents a single face of a 4-planar, orthogonal layout.");
		cl.def( pybind11::init<int &>(), pybind11::arg("G") );

		cl.def("initWithEdgeSeq", (void (dialect::Face::*)(const int &)) &dialect::Face::initWithEdgeSeq, "A method to build the Face, based on the clockwise sequence of \"edges\"\n         of which it is made up; here an \"edge\" is a mere IdPair.\n\nC++: dialect::Face::initWithEdgeSeq(const int &) --> void", pybind11::arg("edges"));
		cl.def("getNodeSeq", (int (dialect::Face::*)()) &dialect::Face::getNodeSeq, "Access the sequence (vector) of Nodes belonging to the Face,\n         in clockwise order.\n\nC++: dialect::Face::getNodeSeq() --> int");
		cl.def("getSides", (int (dialect::Face::*)()) &dialect::Face::getSides, "Get a copy of the vector of Sides.\n\nC++: dialect::Face::getSides() --> int");
		cl.def("getNexusLookup", (int (dialect::Face::*)()) &dialect::Face::getNexusLookup, "Get a copy of the Nexus lookup.\n\nC++: dialect::Face::getNexusLookup() --> int");
		cl.def("containsNodeIdSeq", (bool (dialect::Face::*)(int) const) &dialect::Face::containsNodeIdSeq, "Utility method, to test whether the Face contains a given sequence\n         of Node IDs, in clockwise cyclic order.\n\nC++: dialect::Face::containsNodeIdSeq(int) const --> bool", pybind11::arg("idSeq"));
		cl.def("getGraph", (int (dialect::Face::*)()) &dialect::Face::getGraph, "Access the underlying Graph.\n\nC++: dialect::Face::getGraph() --> int");
		cl.def("id", (unsigned int (dialect::Face::*)() const) &dialect::Face::id, "Access the unique ID of a given instance.\n\n \n  The ID.\n\nC++: dialect::Face::id() const --> unsigned int");
		cl.def("isExternal", (bool (dialect::Face::*)() const) &dialect::Face::isExternal, "Check whether this is the external face or not.\n\nC++: dialect::Face::isExternal() const --> bool");
		cl.def("toString", (int (dialect::Face::*)() const) &dialect::Face::toString, "Get a string representation.\n\nC++: dialect::Face::toString() const --> int");
		cl.def("listAllPossibleTreePlacements", (void (dialect::Face::*)(int &, int, int)) &dialect::Face::listAllPossibleTreePlacements, "Compute all the possible ways of placing a given Tree into this Face,\n         at a given root Node belonging to this Face.\n\n \n  A vector of TreePlacements to which all those allocated by this\n                  method are to be added.\n \n\n  The Tree to be placed.\n \n\n  The Node, belonging to this Face, where the Tree is to attach.\n\nC++: dialect::Face::listAllPossibleTreePlacements(int &, int, int) --> void", pybind11::arg("tps"), pybind11::arg("tree"), pybind11::arg("root"));
		cl.def("inwardDirsAvailable", (int (dialect::Face::*)(int)) &dialect::Face::inwardDirsAvailable, "List the compass directions in which an edge could point if it were\n         anchored at the given Node, and pointed inward, into the Face.\n\nC++: dialect::Face::inwardDirsAvailable(int) --> int", pybind11::arg("node"));
		cl.def("insertTreeNode", [](dialect::Face &o, int const & a0) -> void { return o.insertTreeNode(a0); }, "", pybind11::arg("tp"));
		cl.def("insertTreeNode", (void (dialect::Face::*)(int, double)) &dialect::Face::insertTreeNode, "To be used after the face has been expanded to make room for the tree.\n         This method adds a large node to the graph, representing the bounding\n         box of the tree, with padding.\n         The treenode is constrained to lie beside its root node.\n \n\n  A TreePlacement representing the Tree to be placed.\n \n\n  Optional padding to be added to the tree box.\n \n\n TreePlacement::getTreeBox for interpretation of the padding.\n\nC++: dialect::Face::insertTreeNode(int, double) --> void", pybind11::arg("tp"), pybind11::arg("padding"));
		cl.def("computeCollateralProjSeq", [](dialect::Face &o, int const & a0) -> int { return o.computeCollateralProjSeq(a0); }, "", pybind11::arg("tp"));
		cl.def("computeCollateralProjSeq", (int (dialect::Face::*)(int, double)) &dialect::Face::computeCollateralProjSeq, "Compute a projection sequence to remove/prevent overlaps between the given\n         TreePlacement's tree box, and any existing tree boxes or ordinary perimeter\n         Nodes on relevant Sides of this Face.\n \n\n  The TreePlacement to be added to this Face.\n \n\n  Optional padding for the new tree box.\n \n\n  A ProjSeq representing the computed projection sequence.\n\n \n  In the case where tp's root lies on two sides of the face, these two\n sides must be aligned in complementary dimensions (i.e. one in x, and one\n in y), so the sepcos generated here are always independent.\n\n That is, if each side has an existing treenode that must be pushed away,\n the sepco for one tree will never achieve the push for the other, since\n these pushes /must/ be done in complementary dimensions.\n\n Therefore there is no need to wait until after the first removal has been\n actually performed to compute the sepco for the second removal; it cannot\n be affected by the first one. This means we can safely compute them simultaneously.\n\nC++: dialect::Face::computeCollateralProjSeq(int, double) --> int", pybind11::arg("tp"), pybind11::arg("padding"));
		cl.def("applyProjSeq", (bool (dialect::Face::*)(class dialect::ProjSeq &)) &dialect::Face::applyProjSeq, "Convenience function for applying a ProjSeq with all the appropriate options.\n \n\n  The ProjSeq to be applied.\n \n\n boolean, saying whether all the projections were successful.\n\nC++: dialect::Face::applyProjSeq(class dialect::ProjSeq &) --> bool", pybind11::arg("ps"));
		cl.def("doCollateralExpansion", [](dialect::Face &o, int const & a0) -> int { return o.doCollateralExpansion(a0); }, "", pybind11::arg("tp"));
		cl.def("doCollateralExpansion", (int (dialect::Face::*)(int, double)) &dialect::Face::doCollateralExpansion, "Perform collateral expansion for a given TreePlacement. This means\n         pushing Nodes and tree boxes on relevant Sides out of the way, to make\n         room for the new tree box.\n \n\n  The TreePlacement requiring space.\n \n\n  Optional padding to be added to the new tree box. Leave\n                     negative if you want padding equal to iel/4 to be automatically\n                     applied, where iel is the underlying graph's current ideal edge\n                     length.\n \n\n  The ProjSeq that was used to achieve the required expansion. This\n          ProjSeq will have been already evaluated and applied when returned.\n \n\n  Runtime exception if any of the collateral expansion projections\n          are infeasible. In theory this should never happen.\n\nC++: dialect::Face::doCollateralExpansion(int, double) --> int", pybind11::arg("tp"), pybind11::arg("padding"));
		cl.def("buildBdrySegsFacingOneDir", [](dialect::Face &o, int const & a0, int & a1, int & a2) -> void { return o.buildBdrySegsFacingOneDir(a0, a1, a2); }, "", pybind11::arg("facingDir"), pybind11::arg("closedSegs"), pybind11::arg("openSegs"));
		cl.def("buildBdrySegsFacingOneDir", (void (dialect::Face::*)(int, int &, int &, int)) &dialect::Face::buildBdrySegsFacingOneDir, "Build LineSegments to represent all those segments of the internal boundary\n         of this Face that face in a given direction. These segments can represent\n         aligned Edges, or parts of boundaries of Nodes or tree boxes.\n \n\n  CardinalDir telling which side the segments should face.\n \n\n  Vector in which to store all constructed closed segments.\n \n\n  Vector in which to store all constructed open segments.\n \n\n  Optional TreePlacement whose collateral tree boxes should be ignored.\n\n \n  Whether a boundary segment is closed or open means whether one crosses the interior\n boundary of the face at the endpoints (yes for closed, no for open).\n\n For example, if facingDir is SOUTH, then closedSegs will get one LineSegment for every \n horizontal Edge in the Face, while openSegs will get a LineSegment representing the \n southern boundary of (a) each Node in the Face, and (b) each Tree box in the Face.\n\nC++: dialect::Face::buildBdrySegsFacingOneDir(int, int &, int &, int) --> void", pybind11::arg("facingDir"), pybind11::arg("closedSegs"), pybind11::arg("openSegs"), pybind11::arg("ignoreTP"));
		cl.def("buildBestProjSeq", [](dialect::Face &o, int const & a0) -> int { return o.buildBestProjSeq(a0); }, "", pybind11::arg("tp"));
		cl.def("buildBestProjSeq", [](dialect::Face &o, int const & a0, double const & a1) -> int { return o.buildBestProjSeq(a0, a1); }, "", pybind11::arg("tp"), pybind11::arg("padding"));
		cl.def("buildBestProjSeq", [](dialect::Face &o, int const & a0, double const & a1, bool const & a2) -> int { return o.buildBestProjSeq(a0, a1, a2); }, "", pybind11::arg("tp"), pybind11::arg("padding"), pybind11::arg("doCostlierDimensionFirst"));
		cl.def("buildBestProjSeq", (int (dialect::Face::*)(int, double, bool, int)) &dialect::Face::buildBestProjSeq, "Build the best projection sequence for a given tree placement.\n \n\n  The TreePlacement to be added to this Face.\n \n\n  Optional padding for the new tree box.\n \n\n  See TreePlacement::buildBestProjSeq.\n \n\n  See defn of ExpansionEstimateMethod enum class.\n \n\n  A ProjSeq representing the computed projection sequence.\n\nC++: dialect::Face::buildBestProjSeq(int, double, bool, int) --> int", pybind11::arg("tp"), pybind11::arg("padding"), pybind11::arg("doCostlierDimensionFirst"), pybind11::arg("estimateMethod"));
		cl.def("getAllSidesOppositeSegment", [](dialect::Face const &o, struct dialect::LineSegment & a0) -> int { return o.getAllSidesOppositeSegment(a0); }, "", pybind11::arg("seg"));
		cl.def("getAllSidesOppositeSegment", (int (dialect::Face::*)(struct dialect::LineSegment &, bool) const) &dialect::Face::getAllSidesOppositeSegment, "Get all the Sides of this Face that lie opposite a given LineSegment.\n \n\n  The LineSegment in question.\n \n\n  Set true if you want to consider the overlap with the LineSegment's\n                          open interval instead of closed (the default).\n \n\n  Vector of Sides.\n\nC++: dialect::Face::getAllSidesOppositeSegment(struct dialect::LineSegment &, bool) const --> int", pybind11::arg("seg"), pybind11::arg("openInterval"));
		cl.def("getAllTreePlacements", (int (dialect::Face::*)() const) &dialect::Face::getAllTreePlacements, "Get all TreePlacements that have been added to this Face.\n \n\n  Vector of TreePlacements.\n\nC++: dialect::Face::getAllTreePlacements() const --> int");
		cl.def("getSetOfAllTreePlacements", (int (dialect::Face::*)() const) &dialect::Face::getSetOfAllTreePlacements, "Get the set of all TreePlacements that have been added to this Face.\n \n\n  Set of TreePlacements.\n\nC++: dialect::Face::getSetOfAllTreePlacements() const --> int");
		cl.def("getAllTreePlacements", (void (dialect::Face::*)(int &) const) &dialect::Face::getAllTreePlacements, "Get all TreePlacements that have been added to this Face.\n \n\n  Vector of TreePlacements to which those belonging to this\n                  Face should be added.\n\nC++: dialect::Face::getAllTreePlacements(int &) const --> void", pybind11::arg("tps"));
		cl.def("getNumTreesByGrowthDir", [](dialect::Face const &o, int & a0) -> void { return o.getNumTreesByGrowthDir(a0); }, "", pybind11::arg("counts"));
		cl.def("getNumTreesByGrowthDir", (void (dialect::Face::*)(int &, bool) const) &dialect::Face::getNumTreesByGrowthDir, "After tree placements have been chosen and performed, get a count of trees\n         by growth direction.\n \n\n  Map into which the counts should be added.\n \n\n  Set true if for each tree you actually want to count its number\n                         of nodes. In other words, the final counts you get actually indicate\n                         the number of nodes in trees that grow in the given directions.\n\nC++: dialect::Face::getNumTreesByGrowthDir(int &, bool) const --> void", pybind11::arg("counts"), pybind11::arg("scaleBySize"));
	}
}
