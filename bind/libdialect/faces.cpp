#include <functional>
#include <iterator>
#include <libavoid/geomtypes.h>
#include <libavoid/router.h>
#include <libcola/cluster.h>
#include <libdialect/constraints.h>
#include <libdialect/faces.h>
#include <libdialect/graphs.h>
#include <libdialect/opts.h>
#include <libdialect/ortho.h>
#include <libdialect/routing.h>
#include <libdialect/treeplacement.h>
#include <libdialect/trees.h>
#include <libvpsc/rectangle.h>
#include <map>
#include <memory>
#include <set>
#include <sstream> // __str__
#include <string>
#include <string_view>
#include <utility>
#include <vector>

#include <functional>
#include <pybind11/pybind11.h>
#include <string>

#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_libdialect_faces(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // dialect::Nexus file:libdialect/faces.h line:182
		pybind11::class_<dialect::Nexus, std::shared_ptr<dialect::Nexus>> cl(M("dialect"), "Nexus", "Regarded as a member of a Face F, a Node u belongs to certain Sides si\n of F. As we traverse the face in the clockwise direction (i.e. so that the\n interior of the face is always to the /right/), each Side si gets a direction,\n and therefore may stand in one of eight relations to Node u: it may be /entering/\n or /exiting/, and this may be from or to any of the four cardinal compass directions.\n\n A single Side may stand in two such relations, as when the Node lies along\n the middle of the Side, or else in just one such relation, as when a Node\n lies at one end or the other.\n\n A Nexus represents a Node in this capacity as a \"joining point\" of several\n Sides of a Face. It stores eight \"slots\" that are either empty or else occupied by\n a Side object.");
		cl.def( pybind11::init<class std::shared_ptr<class dialect::Node>>(), pybind11::arg("u") );

		cl.def( pybind11::init( [](dialect::Nexus const &o){ return new dialect::Nexus(o); } ) );
		cl.def("addSide", (void (dialect::Nexus::*)(class std::shared_ptr<class dialect::Side>)) &dialect::Nexus::addSide, "Add a Side to the Nexus.\n\nC++: dialect::Nexus::addSide(class std::shared_ptr<class dialect::Side>) --> void", pybind11::arg("side"));
		cl.def("toString", (std::string (dialect::Nexus::*)() const) &dialect::Nexus::toString, "Write a string representation.\n\nC++: dialect::Nexus::toString() const --> std::string");
	}
	{ // dialect::FaceSet file:libdialect/faces.h line:251
		pybind11::class_<dialect::FaceSet, std::shared_ptr<dialect::FaceSet>> cl(M("dialect"), "FaceSet", "Holds all the Face objects for a given 4-planar, orthogonal layout,\n and provides methods to use and manage them.");
		cl.def( pybind11::init<class std::shared_ptr<class dialect::Graph> &>(), pybind11::arg("G") );

		cl.def( pybind11::init( [](dialect::FaceSet const &o){ return new dialect::FaceSet(o); } ) );
		cl.def("getNumFaces", (unsigned long (dialect::FaceSet::*)()) &dialect::FaceSet::getNumFaces, "Check how many faces there are.\n\nC++: dialect::FaceSet::getNumFaces() --> unsigned long");
		cl.def("getExternalFace", (class std::shared_ptr<class dialect::Face> (dialect::FaceSet::*)()) &dialect::FaceSet::getExternalFace, "Get the external Face.\n\nC++: dialect::FaceSet::getExternalFace() --> class std::shared_ptr<class dialect::Face>");
	}
	{ // dialect::Face file:libdialect/faces.h line:306
		pybind11::class_<dialect::Face, std::shared_ptr<dialect::Face>> cl(M("dialect"), "Face", "Represents a single face of a 4-planar, orthogonal layout.");
		cl.def( pybind11::init<class std::shared_ptr<class dialect::Graph> &>(), pybind11::arg("G") );

		cl.def( pybind11::init( [](dialect::Face const &o){ return new dialect::Face(o); } ) );
		cl.def("getNexusLookup", (class std::map<unsigned int, class std::shared_ptr<class dialect::Nexus>, struct std::less<unsigned int>, class std::allocator<struct std::pair<const unsigned int, class std::shared_ptr<class dialect::Nexus> > > > (dialect::Face::*)()) &dialect::Face::getNexusLookup, "Get a copy of the Nexus lookup.\n\nC++: dialect::Face::getNexusLookup() --> class std::map<unsigned int, class std::shared_ptr<class dialect::Nexus>, struct std::less<unsigned int>, class std::allocator<struct std::pair<const unsigned int, class std::shared_ptr<class dialect::Nexus> > > >");
		cl.def("getGraph", (class std::shared_ptr<class dialect::Graph> (dialect::Face::*)()) &dialect::Face::getGraph, "Access the underlying Graph.\n\nC++: dialect::Face::getGraph() --> class std::shared_ptr<class dialect::Graph>");
		cl.def("id", (unsigned int (dialect::Face::*)() const) &dialect::Face::id, "Access the unique ID of a given instance.\n\n \n  The ID.\n\nC++: dialect::Face::id() const --> unsigned int");
		cl.def("isExternal", (bool (dialect::Face::*)() const) &dialect::Face::isExternal, "Check whether this is the external face or not.\n\nC++: dialect::Face::isExternal() const --> bool");
		cl.def("toString", (std::string (dialect::Face::*)() const) &dialect::Face::toString, "Get a string representation.\n\nC++: dialect::Face::toString() const --> std::string");
		cl.def("insertTreeNode", [](dialect::Face &o, class std::shared_ptr<class dialect::TreePlacement> const & a0) -> void { return o.insertTreeNode(a0); }, "", pybind11::arg("tp"));
		cl.def("insertTreeNode", (void (dialect::Face::*)(class std::shared_ptr<class dialect::TreePlacement>, double)) &dialect::Face::insertTreeNode, "To be used after the face has been expanded to make room for the tree.\n         This method adds a large node to the graph, representing the bounding\n         box of the tree, with padding.\n         The treenode is constrained to lie beside its root node.\n \n\n  A TreePlacement representing the Tree to be placed.\n \n\n  Optional padding to be added to the tree box.\n \n\n TreePlacement::getTreeBox for interpretation of the padding.\n\nC++: dialect::Face::insertTreeNode(class std::shared_ptr<class dialect::TreePlacement>, double) --> void", pybind11::arg("tp"), pybind11::arg("padding"));
		cl.def("computeCollateralProjSeq", [](dialect::Face &o, class std::shared_ptr<class dialect::TreePlacement> const & a0) -> std::shared_ptr<class dialect::ProjSeq> { return o.computeCollateralProjSeq(a0); }, "", pybind11::arg("tp"));
		cl.def("computeCollateralProjSeq", (class std::shared_ptr<class dialect::ProjSeq> (dialect::Face::*)(class std::shared_ptr<class dialect::TreePlacement>, double)) &dialect::Face::computeCollateralProjSeq, "Compute a projection sequence to remove/prevent overlaps between the given\n         TreePlacement's tree box, and any existing tree boxes or ordinary perimeter\n         Nodes on relevant Sides of this Face.\n \n\n  The TreePlacement to be added to this Face.\n \n\n  Optional padding for the new tree box.\n \n\n  A ProjSeq representing the computed projection sequence.\n\n \n  In the case where tp's root lies on two sides of the face, these two\n sides must be aligned in complementary dimensions (i.e. one in x, and one\n in y), so the sepcos generated here are always independent.\n\n That is, if each side has an existing treenode that must be pushed away,\n the sepco for one tree will never achieve the push for the other, since\n these pushes /must/ be done in complementary dimensions.\n\n Therefore there is no need to wait until after the first removal has been\n actually performed to compute the sepco for the second removal; it cannot\n be affected by the first one. This means we can safely compute them simultaneously.\n\nC++: dialect::Face::computeCollateralProjSeq(class std::shared_ptr<class dialect::TreePlacement>, double) --> class std::shared_ptr<class dialect::ProjSeq>", pybind11::arg("tp"), pybind11::arg("padding"));
		cl.def("applyProjSeq", (bool (dialect::Face::*)(class dialect::ProjSeq &)) &dialect::Face::applyProjSeq, "Convenience function for applying a ProjSeq with all the appropriate options.\n \n\n  The ProjSeq to be applied.\n \n\n boolean, saying whether all the projections were successful.\n\nC++: dialect::Face::applyProjSeq(class dialect::ProjSeq &) --> bool", pybind11::arg("ps"));
		cl.def("doCollateralExpansion", [](dialect::Face &o, class std::shared_ptr<class dialect::TreePlacement> const & a0) -> std::shared_ptr<class dialect::ProjSeq> { return o.doCollateralExpansion(a0); }, "", pybind11::arg("tp"));
		cl.def("doCollateralExpansion", (class std::shared_ptr<class dialect::ProjSeq> (dialect::Face::*)(class std::shared_ptr<class dialect::TreePlacement>, double)) &dialect::Face::doCollateralExpansion, "Perform collateral expansion for a given TreePlacement. This means\n         pushing Nodes and tree boxes on relevant Sides out of the way, to make\n         room for the new tree box.\n \n\n  The TreePlacement requiring space.\n \n\n  Optional padding to be added to the new tree box. Leave\n                     negative if you want padding equal to iel/4 to be automatically\n                     applied, where iel is the underlying graph's current ideal edge\n                     length.\n \n\n  The ProjSeq that was used to achieve the required expansion. This\n          ProjSeq will have been already evaluated and applied when returned.\n \n\n  Runtime exception if any of the collateral expansion projections\n          are infeasible. In theory this should never happen.\n\nC++: dialect::Face::doCollateralExpansion(class std::shared_ptr<class dialect::TreePlacement>, double) --> class std::shared_ptr<class dialect::ProjSeq>", pybind11::arg("tp"), pybind11::arg("padding"));
		cl.def("buildBestProjSeq", [](dialect::Face &o, class std::shared_ptr<class dialect::TreePlacement> const & a0) -> std::shared_ptr<class dialect::ProjSeq> { return o.buildBestProjSeq(a0); }, "", pybind11::arg("tp"));
		cl.def("buildBestProjSeq", [](dialect::Face &o, class std::shared_ptr<class dialect::TreePlacement> const & a0, double const & a1) -> std::shared_ptr<class dialect::ProjSeq> { return o.buildBestProjSeq(a0, a1); }, "", pybind11::arg("tp"), pybind11::arg("padding"));
		cl.def("buildBestProjSeq", [](dialect::Face &o, class std::shared_ptr<class dialect::TreePlacement> const & a0, double const & a1, bool const & a2) -> std::shared_ptr<class dialect::ProjSeq> { return o.buildBestProjSeq(a0, a1, a2); }, "", pybind11::arg("tp"), pybind11::arg("padding"), pybind11::arg("doCostlierDimensionFirst"));
		cl.def("buildBestProjSeq", (class std::shared_ptr<class dialect::ProjSeq> (dialect::Face::*)(class std::shared_ptr<class dialect::TreePlacement>, double, bool, enum dialect::ExpansionEstimateMethod)) &dialect::Face::buildBestProjSeq, "Build the best projection sequence for a given tree placement.\n \n\n  The TreePlacement to be added to this Face.\n \n\n  Optional padding for the new tree box.\n \n\n  See TreePlacement::buildBestProjSeq.\n \n\n  See defn of ExpansionEstimateMethod enum class.\n \n\n  A ProjSeq representing the computed projection sequence.\n\nC++: dialect::Face::buildBestProjSeq(class std::shared_ptr<class dialect::TreePlacement>, double, bool, enum dialect::ExpansionEstimateMethod) --> class std::shared_ptr<class dialect::ProjSeq>", pybind11::arg("tp"), pybind11::arg("padding"), pybind11::arg("doCostlierDimensionFirst"), pybind11::arg("estimateMethod"));
		cl.def("getSetOfAllTreePlacements", (class std::set<class std::shared_ptr<class dialect::TreePlacement>, struct std::less<class std::shared_ptr<class dialect::TreePlacement> >, class std::allocator<class std::shared_ptr<class dialect::TreePlacement> > > (dialect::Face::*)() const) &dialect::Face::getSetOfAllTreePlacements, "Get the set of all TreePlacements that have been added to this Face.\n \n\n  Set of TreePlacements.\n\nC++: dialect::Face::getSetOfAllTreePlacements() const --> class std::set<class std::shared_ptr<class dialect::TreePlacement>, struct std::less<class std::shared_ptr<class dialect::TreePlacement> >, class std::allocator<class std::shared_ptr<class dialect::TreePlacement> > >");
	}
	{ // dialect::Tree file:libdialect/trees.h line:44
		pybind11::class_<dialect::Tree, std::shared_ptr<dialect::Tree>> cl(M("dialect"), "Tree", "");
		cl.def( pybind11::init<class std::shared_ptr<class dialect::Graph>, class std::shared_ptr<class dialect::Node>>(), pybind11::arg("G"), pybind11::arg("root") );

		cl.def( pybind11::init( [](dialect::Tree const &o){ return new dialect::Tree(o); } ) );
		cl.def("symmetricLayout", [](dialect::Tree &o, enum dialect::CardinalDir const & a0, double const & a1, double const & a2) -> void { return o.symmetricLayout(a0, a1, a2); }, "", pybind11::arg("growthDir"), pybind11::arg("nodeSep"), pybind11::arg("rankSep"));
		cl.def("symmetricLayout", (void (dialect::Tree::*)(enum dialect::CardinalDir, double, double, bool)) &dialect::Tree::symmetricLayout, "Apply the Symmetric Layout algorithm of Manning & Atallah\n             See Manning, Joseph, and Mikhail J. Atallah.\n             \"Fast detection and display of symmetry in trees.\" (1985).\n\n \n  The direction in which the tree should grow.\n \n\n  Minimal gap between nodes on the same rank.\n \n\n  Minimal separation between ranks.\n \n\n  If true, the broadest and deepest subtrees are\n                             placed near the centre; if false, the opposite.\n\nC++: dialect::Tree::symmetricLayout(enum dialect::CardinalDir, double, double, bool) --> void", pybind11::arg("growthDir"), pybind11::arg("nodeSep"), pybind11::arg("rankSep"), pybind11::arg("convexOrdering"));
		cl.def("flip", (void (dialect::Tree::*)()) &dialect::Tree::flip, "Flip the tree's layout over the axis running through the root node\n         and aligned with the growth direction.\n\nC++: dialect::Tree::flip() --> void");
		cl.def("translate", (void (dialect::Tree::*)(class Avoid::Point)) &dialect::Tree::translate, "Translate the tree's layout by a given vector.\n\n \n  The vector by which to translate.\n\nC++: dialect::Tree::translate(class Avoid::Point) --> void", pybind11::arg("vect"));
		cl.def("rotate", (void (dialect::Tree::*)(enum dialect::CardinalDir)) &dialect::Tree::rotate, "Rotate the tree's layout to attain a desired growth direction.\n\n \n  The desired growth direction.\n\nC++: dialect::Tree::rotate(enum dialect::CardinalDir) --> void", pybind11::arg("dg"));
		cl.def("rotateGrowthDirCW", (void (dialect::Tree::*)(unsigned int)) &dialect::Tree::rotateGrowthDirCW, "Do not rotate the layout, but simply update the Tree's growth direction by rotating clockwise.\n \n\n  How many quarter turns clockwise to rotate the growth direction.\n\nC++: dialect::Tree::rotateGrowthDirCW(unsigned int) --> void", pybind11::arg("quarterTurns"));
		cl.def("underlyingGraph", (class std::shared_ptr<class dialect::Graph> (dialect::Tree::*)() const) &dialect::Tree::underlyingGraph, "Access the Tree's underlying Graph.\n\nC++: dialect::Tree::underlyingGraph() const --> class std::shared_ptr<class dialect::Graph>");
		cl.def("getRootNode", (class std::shared_ptr<class dialect::Node> (dialect::Tree::*)() const) &dialect::Tree::getRootNode, "Access the Tree's root Node.\n\nC++: dialect::Tree::getRootNode() const --> class std::shared_ptr<class dialect::Node>");
		cl.def("repr", (std::string (dialect::Tree::*)() const) &dialect::Tree::repr, "Write a string representation of this Tree.\n         Useful for debugging.\n\nC++: dialect::Tree::repr() const --> std::string");
		cl.def("getRootNodeID", (unsigned int (dialect::Tree::*)() const) &dialect::Tree::getRootNodeID, "Check the ID of the root ndoe.\n\nC++: dialect::Tree::getRootNodeID() const --> unsigned int");
		cl.def("isSymmetrical", (bool (dialect::Tree::*)() const) &dialect::Tree::isSymmetrical, "Check whether the layout is symmetrical.\n\n \n  Just because you have called a Tree's symmetricLayout method, does not\n        mean it acutally got a symmetrical layout! That is only possible if the\n        Tree's structure is in fact symmetrical. This method informs you whether\n        the latter is the case.\n\nC++: dialect::Tree::isSymmetrical() const --> bool");
		cl.def("buildRootlessBox", (class std::shared_ptr<class dialect::Node> (dialect::Tree::*)(enum dialect::CardinalDir) const) &dialect::Tree::buildRootlessBox, "Determine the size of the tree minus the root node, and the position\n         relative to the root node.\n\n \n  Before calling this method, the Tree should have been laid out, so the root\n        node should be centred at (0, 0), and the Tree's growth direction should be set.\n\n \n  The growth direction with respect to which the box should be computed.\n\n \n  A Node whose dimensions w x h gives the dimensions of the bounding box\n          of the tree, minus the root node (but not minus the inter-rank space between\n          the root node and the first rank), and whose position (x, y) gives the\n          vector from the centre of the root node to the centre of this box.\n\nC++: dialect::Tree::buildRootlessBox(enum dialect::CardinalDir) const --> class std::shared_ptr<class dialect::Node>", pybind11::arg("growthDir"));
		cl.def("size", (unsigned long (dialect::Tree::*)() const) &dialect::Tree::size, "Check how many nodes are in the tree.\n\nC++: dialect::Tree::size() const --> unsigned long");
		cl.def("addNetworkToRoutingAdapter", [](dialect::Tree &o, struct dialect::RoutingAdapter & a0, enum dialect::TreeRoutingType const & a1) -> void { return o.addNetworkToRoutingAdapter(a0, a1); }, "", pybind11::arg("ra"), pybind11::arg("trt"));
		cl.def("addNetworkToRoutingAdapter", (void (dialect::Tree::*)(struct dialect::RoutingAdapter &, enum dialect::TreeRoutingType, class std::shared_ptr<class dialect::Graph>)) &dialect::Tree::addNetworkToRoutingAdapter, "Add the nodes and edges of this Tree to a RoutingAdapter.\n         This is useful either for routing just the Tree itself, or for adding the internal part\n         of the tree (i.e. everything except the root node) to another graph where the tree is\n         rooted.\n \n\n  The RoutingAdapter we are to augment.\n \n\n  Which type of routing you want.\n \n\n  The core Graph in the case that this Tree has been peeled off a core, and is\n                  to be reattched.\n \n\n If a core Graph is given, then the root node of the tree will be omitted from the RoutingAdapter.\n\nC++: dialect::Tree::addNetworkToRoutingAdapter(struct dialect::RoutingAdapter &, enum dialect::TreeRoutingType, class std::shared_ptr<class dialect::Graph>) --> void", pybind11::arg("ra"), pybind11::arg("trt"), pybind11::arg("core"));
		cl.def("addNetwork", (void (dialect::Tree::*)(class dialect::Graph &, class std::map<unsigned int, class std::shared_ptr<class dialect::Node>, struct std::less<unsigned int>, class std::allocator<struct std::pair<const unsigned int, class std::shared_ptr<class dialect::Node> > > > &, class std::map<unsigned int, class std::shared_ptr<class dialect::Edge>, struct std::less<unsigned int>, class std::allocator<struct std::pair<const unsigned int, class std::shared_ptr<class dialect::Edge> > > > &)) &dialect::Tree::addNetwork, "Add the Nodes and Edges of this tree to a Graph.\n \n\n  The Graph to which the Nodes and Edges are to be added.\n \n\n  A place to record the tree nodes that are constructred.\n \n\n  A place to record the tree edges that are constructred.\n \n\n  Before adding each Node to the given Graph G we check whether G already has a Node that reports\n        the same ID; if it does, we do not add the Node. This is useful so that root nodes are not\n        overwritten when reattaching peeled trees to a core graph.\n\nC++: dialect::Tree::addNetwork(class dialect::Graph &, class std::map<unsigned int, class std::shared_ptr<class dialect::Node>, struct std::less<unsigned int>, class std::allocator<struct std::pair<const unsigned int, class std::shared_ptr<class dialect::Node> > > > &, class std::map<unsigned int, class std::shared_ptr<class dialect::Edge>, struct std::less<unsigned int>, class std::allocator<struct std::pair<const unsigned int, class std::shared_ptr<class dialect::Edge> > > > &) --> void", pybind11::arg("G"), pybind11::arg("treeNodes"), pybind11::arg("treeEdges"));
		cl.def("addConstraints", (void (dialect::Tree::*)(class dialect::Graph &, bool)) &dialect::Tree::addConstraints, "Set constraints in a given Graph's SepMatrix in order to maintain the layout of the tree.\n \n\n  The Graph to which the constraints are to be added.\n \n\n  Say whether an alignment constraint should be set between the root node and\n                       a centre node (if present) in the first rank. For example, this should be set\n                       false in the case of a peeled tree being reattached with ordinal placement direction.\n \n\n  The given Graph G must have Nodes matching the IDs of those in this Tree.\n\nC++: dialect::Tree::addConstraints(class dialect::Graph &, bool) --> void", pybind11::arg("G"), pybind11::arg("alignRoot"));
		cl.def("addBufferNodesAndConstraints", (void (dialect::Tree::*)(class dialect::Graph &, class std::map<unsigned int, class std::shared_ptr<class dialect::Node>, struct std::less<unsigned int>, class std::allocator<struct std::pair<const unsigned int, class std::shared_ptr<class dialect::Node> > > > &)) &dialect::Tree::addBufferNodesAndConstraints, "Add buffer nodes to help keep separation between the nodes of the tree and the remainder of\n         the given graph G. Set constraints to keep the buffer nodes in place.\n \n\n  The Graph to which the Nodes and constraints are to be added.\n \n\n  A place to record the buffer nodes that are constructred.\n \n\n  This Tree's addNetworkAndConstraints should have been called first, for the same Graph G.\n\nC++: dialect::Tree::addBufferNodesAndConstraints(class dialect::Graph &, class std::map<unsigned int, class std::shared_ptr<class dialect::Node>, struct std::less<unsigned int>, class std::allocator<struct std::pair<const unsigned int, class std::shared_ptr<class dialect::Node> > > > &) --> void", pybind11::arg("G"), pybind11::arg("bufferNodes"));
	}
}
